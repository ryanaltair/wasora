.\" Automatically generated by Pandoc 2.9.2
.\"
.TH "WASORA" "1" "" "Wasora User Manual" ""
.hy
.SH NAME
.PP
wasora - wasora\[cq]s an advanced suite for optimization & reactor
analysis
.SH SYNOPSIS
.PP
wasora [\f[I]options\f[R]] input-file
[\f[I]optional_extra_arguments\f[R]]\&...
.SH DESCRIPTION
.PP
Wasora (https://www.seamplex.com/wasora) is a (relatively) high-level
tool to perform mathematical computations.
It also provides a framework which other particular computational codes
can use.
It is a free computational tool designed to aid a cognizant
expert\[em]i.e.\ you, whether an engineer, scientist, technician, geek,
etc.\[em]to analyze complex systems by solving mathematical problems by
means of a high-level plain-text input file containing
.IP \[bu] 2
algebraic expressions,
.IP \[bu] 2
data for function interpolation,
.IP \[bu] 2
differential equations, and
.IP \[bu] 2
output instructions
.PP
among other facilities.
.PP
For example, the famous chaotic Lorenz\[cq] dynamical
system (http://en.wikipedia.org/wiki/Lorenz_system)\[em]the one of the
butterfly\[em]whose differential equations are
.PP
.RS
\f[I]x\[u0307]\f[R]\[u2004]=\[u2004]\f[I]\[*s]\f[R]\[u2005]\[md]\[u2005](\f[I]y\f[R]\[u2005]\[mi]\[u2005]\f[I]x\f[R])
.RE
.RS
\f[I]y\[u0307]\f[R]\[u2004]=\[u2004]\f[I]x\f[R]\[u2005]\[md]\[u2005](\f[I]r\f[R]\[u2005]\[mi]\[u2005]\f[I]z\f[R])\[u2005]\[mi]\[u2005]\f[I]y\f[R]
.RE
.RS
\f[I]z\[u0307]\f[R]\[u2004]=\[u2004]\f[I]x\f[R]\f[I]y\f[R]\[u2005]\[mi]\[u2005]\f[I]b\f[R]\f[I]z\f[R]
.RE
.PP
where \f[I]\[*s]\f[R]\[u2004]=\[u2004]10,
\f[I]b\f[R]\[u2004]=\[u2004]8/3 and \f[I]r\f[R]\[u2004]=\[u2004]28 are
the classical parameters that generate the butterfly as presented by
Edward Lorenz back in his seminal 1963 paper Deterministic non-periodic
flow (http://journals.ametsoc.org/doi/abs/10.1175/1520-0469%281963%29020%3C0130%3ADNF%3E2.0.CO%3B2),
can be solved with wasora by writing the equations in the input file as
naturally as possible, as illustrated in the input file that follows:
.IP
.nf
\f[C]
# lorenz\[cq] seminal dynamical system
PHASE_SPACE x y z
end_time = 40

CONST sigma r b
sigma = 10            # parameters
r = 28
b = 8/3

x_0 = -11             # initial conditions
y_0 = -16
z_0 = 22.5

# the dynamical system
x_dot .= sigma*(y - x)
y_dot .= x*(r - z) - y
z_dot .= x*y - b*z

PRINT t x y z HEADER
\f[R]
.fi
.PP
Following the UNIX
Philosophy (https://en.wikipedia.org/wiki/Unix_philosophy), wasora\[cq]s
output can be piped for example to Gnuplot (http://gnuplot.info/) in
order to obtain a beautiful figure:
.IP
.nf
\f[C]
wasora lorenz.was | gnuplot -e \[dq]splot \[aq]-\[aq] u 2:3:4 w l ti \[aq]\[aq]\[dq]
\f[R]
.fi
.PP
[IMAGE: The Lorenz attractor computed by wasora]
.PP
At a first glance, wasora may look as another high-level interpreted
programming language, but\[em]hopefully\[em]it is not: wasora should be
seen as a
syntactically-sweetened (http://en.wikipedia.org/wiki/Syntactic_sugar)
way to ask a computer to perform a certain mathematical computation
(which is what computers do).
.SH OPTIONS
.TP
\f[B]\f[CB]-d\f[B]\f[R] or \f[B]\f[CB]--debug\f[B]\f[R]
Start in debug mode
.TP
\f[B]\f[CB]--node-debug\f[B]\f[R]
Ignore standard input, avoid debug mode
.TP
\f[B]\f[CB]-l\f[B]\f[R] or \f[B]\f[CB]--list\f[B]\f[R]
List defined symbols and exit
.TP
\f[B]\f[CB]-h\f[B]\f[R] or \f[B]\f[CB]--help\f[B]\f[R]
Display this help and exit
.TP
\f[B]\f[CB]-i\f[B]\f[R] or \f[B]\f[CB]--info\f[B]\f[R]
Display detailed code information and exit
.TP
\f[B]\f[CB]-v\f[B]\f[R] or \f[B]\f[CB]--version\f[B]\f[R]
Display version information and exit
.PP
Input file instructions are read from standard input if a dash
\f[C]-\f[R] is passed as \f[C]input-file\f[R].
.PP
Wasora accepts \f[I]optional extra arguments\f[R] which are then
verbatimly replaced in the input file as \f[C]$1\f[R], \f[C]$2\f[R], and
so on.
So for example if an input file has a line like this
.IP
.nf
\f[C]
PRINT \[dq]$1 squared is\[dq] ($1)\[ha]2
\f[R]
.fi
.PP
Then two different meshes called \f[C]one.msh\f[R] and \f[C]two.msh\f[R]
can successively be used in two runs with the same input file by calling
Fino as
.IP
.nf
\f[C]
$ wasora input.was 2
2 squared is    4
$ wasora input.was 3
3 squared is    9
$ 
\f[R]
.fi
.SH REFERENCE
.SS Keywords
.SS =
.RS
.PP
Assign an expression to a variable, a vector or a matrix.
.RE
.IP
.nf
\f[C]
<var>[ [<expr_tmin>, <expr_tmax>] | 
<expr_t> ] = <expr> <vector>(<expr_i>)[<expr_i_min, expr_i_max>] [ [<expr_tmin>, <expr_tmax>] | 
<expr_t> ] = <expr> <matrix>(<expr_i>,<expr_j>)[<expr_i_min, expr_i_max; expr_j_min, expr_j_max>] [ [<expr_tmin>, <expr_tmax>] | 
<expr_t> ] = <expr>
\f[R]
.fi
.SS _.=
.RS
.PP
Add an equation to the DAE system to be solved in the phase space
spanned by \f[C]PHASE_SPACE\f[R].
.RE
.IP
.nf
\f[C]
{ 0[(i[,j]][<imin:imax[;jmin:jmax]>] | <expr1> } .= <expr2>
\f[R]
.fi
.SS ABORT
.RS
.PP
Catastrophically abort the execution and quit wasora.
.RE
.IP
.nf
\f[C]
ABORT
\f[R]
.fi
.PP
Whenever the instruction \f[C]ABORT\f[R] is executed, wasora quits
without closing files or unlocking shared memory objects.
The objective of this instruction is, as illustrated in the examples,
either to debug complex input files and check the values of certain
variables or to conditionally abort the execution using \f[C]IF\f[R]
clauses.
.SS ALIAS
.RS
.PP
Define a scalar alias of an already-defined indentifier.
.RE
.IP
.nf
\f[C]
ALIAS { <new_var_name> IS <existing_object> | <existing_object> AS <new_name> }
\f[R]
.fi
.PP
The existing object can be a variable, a vector element or a matrix
element.
In the first case, the name of the variable should be given as the
existing object.
In the second case, to alias the second element of vector \f[C]v\f[R] to
the new name \f[C]new\f[R], \f[C]v(2)\f[R] should be given as the
existing object.
In the third case, to alias second element (2,3) of matrix \f[C]M\f[R]
to the new name \f[C]new\f[R], \f[C]M(2,3)\f[R] should be given as the
existing object.
.SS CALL
.RS
.PP
Call a previously dynamically-loaded user-provided routine.
.RE
.IP
.nf
\f[C]
CALL <name> [ expr_1 expr_2 ... expr_n ]
\f[R]
.fi
.SS CLOSE
.RS
.PP
Explicitly close an already-\f[C]OPEN\f[R]ed file.
.RE
.IP
.nf
\f[C]
CLOSE
\f[R]
.fi
.SS CONST
.RS
.PP
Mark a scalar variable, vector or matrix as a constant.
.RE
.IP
.nf
\f[C]
CONST name_1 [ <name_2> ] ... [ <name_n> ]
\f[R]
.fi
.SS DEFAULT_ARGUMENT_VALUE
.RS
.PP
Give a default value for an optional commandline argument.
.RE
.IP
.nf
\f[C]
DEFAULT_ARGUMENT_VALUE <constant> <string>
\f[R]
.fi
.PP
If a \f[C]$n\f[R] construction is found in the input file but the
commandline argument was not given, the default behavior is to fail
complaining that an extra argument has to be given in the commandline.
With this keyword, a default value can be assigned if no argument is
given, thus avoiding the failure and making the argument optional.
.SS DIFFERENTIAL
.RS
.PP
Explicitly mark variables, vectors or matrices as \[lq]differential\[rq]
to compute intial conditions of DAE systems.
.RE
.IP
.nf
\f[C]
DIFFERENTIAL { <var_1> <var_2> ... | <vector_1> <vector_2> ... | <matrix_1> <matrix_2> ... }
\f[R]
.fi
.SS DO_NOT_EVALUATE_AT_PARSE_TIME
.RS
.PP
Ask wasora not to evaluate assignments at parse time.
.RE
.IP
.nf
\f[C]
DO_NOT_EVALUATE_AT_PARSE_TIME
\f[R]
.fi
.SS FILE
.RS
.PP
Define a file, either as input or as output, for further usage.
.RE
.IP
.nf
\f[C]
< FILE | OUTPUT_FILE | INPUT_FILE > <name> <printf_format> [ expr_1 expr_2 ... expr_n ] [ INPUT | OUTPUT | MODE <fopen_mode> ] [ OPEN | DO_NOT_OPEN ]
\f[R]
.fi
.SS FIT
.RS
.PP
Fit a function of one or more arguments to a set of pointwise-defined
data.
.RE
.IP
.nf
\f[C]
FIT <function_to_be_fitted> TO <function_with_data>
 VIA <var_1> <var_2> ... <var_n>
 [ GRADIENT <expr_1> <expr_2> ... <expr_n> ]
 [ RANGE_MIN <expr_1> <expr_2> ... <expr_n> ]
 [ RANGE_MAX <expr_1> <expr_2> ... <expr_n> ]
 [ DELTAEPSREL <expr> ] [ DELTAEPSABS <expr> ] [ MAX_ITER <expr> ]
 [ VERBOSE ] [ RERUN | DO_NOT_RERUN ]
\f[R]
.fi
.PP
The function with the data has to be point-wise defined (i.e.\ a
\f[C]FUNCTION\f[R] read from a file with inline \f[C]DATA\f[R]).
The function to be fitted has to be parametrized with at least one of
the variables provided after the \f[C]VIA\f[R] keyword.
Only the names of the functions have to be given, not the arguments.
Both functions have to have the same number of arguments.
The initial guess of the solution is given by the initial value of the
variables listed in the \f[C]VIA\f[R] keyword.
Analytical expressions for the gradient of the function to be fitted
with respect to the parameters to be fitted can be optionally given with
the \f[C]GRADIENT\f[R] keyword.
If none is provided, the gradient will be computed numerically using
finite differences.
A range over which the residuals are to be minimized can be given with
\f[C]RANGE_MIN\f[R] and \f[C]RANGE_MAX\f[R].
For multidimensional fits, the range is an hypercube.
If no range is given, all the definition points of the function with the
data are used for the fit.
Convergence can be controlled by given the relative and absolute
tolreances with \f[C]DELTAEPSREL\f[R] (default 1e-4) and
\f[C]DELTAEPSABS\f[R] (default 1e-6), and with the maximum number of
iterations \f[C]MAX_ITER\f[R] (default 100).
If the optional keyword \f[C]VERBOSE\f[R] is given, some data of the
intermediate steps is written in the standard output.
.SS FUNCTION
.RS
.PP
Define a function of one or more variables.
.RE
.IP
.nf
\f[C]
FUNCTION <name>(<var_1>[,var2,...,var_n]) { [ = <expr> | FILE_PATH <file_path> | ROUTINE <name> | | MESH <name> { DATA <new_vector_name> | VECTOR <existing_vector_name> } { NODES | CELLS } | [ VECTOR_DATA <vector_1> <vector_2> ... <vector_n> <vector_n+1> ] } [COLUMNS <expr_1> <expr_2> ... <expr_n> <expr_n+1> ] [ INTERPOLATION { linear | polynomial | spline | spline_periodic | akima | akima_periodic | steffen | nearest | shepard | shepard_kd | bilinear } ] [ INTERPOLATION_THRESHOLD <expr> ] [ SHEPARD_RADIUS <expr> ] [ SHEPARD_EXPONENT <expr> ] [ SIZES <expr_1> <expr_2> ... <expr_n> ] [ X_INCREASES_FIRST <expr> ] [ DATA <num_1> <num_2> ... <num_N> ]
\f[R]
.fi
.PP
The number of variables \f[I]n\f[R] is given by the number of arguments
given between parenthesis after the function name.
The arguments are defined as new variables if they had not been already
defined as variables.
If the function is given as an algebraic expression, the short-hand
operator \f[C]:=\f[R] can be used.
That is to say, \f[C]FUNCTION f(x) = x\[ha]2\f[R] is equivalent to
\f[C]f(x) := x\[ha]2\f[R].
If a \f[C]FILE_PATH\f[R] is given, an ASCII file containing at least
\f[I]n\f[R]\[u2005]+\[u2005]1 columns is expected.
By default, the first \f[I]n\f[R] columns are the values of the
arguments and the last column is the value of the function at those
points.
The order of the columns can be changed with the keyword
\f[C]COLUMNS\f[R], which expects \f[I]n\f[R]\[u2005]+\[u2005]1
expressions corresponding to the column numbers.
A function of type \f[C]ROUTINE\f[R] calls an already-defined
user-provided routine using the \f[C]CALL\f[R] keyword and passes the
values of the variables in each required evaluation as a
\f[C]double *\f[R] argument.
If \f[C]MESH\f[R] is given, the definition points are the nodes or the
cells of the mesh.
The function arguments should be (\f[I]x\f[R]),
(\f[I]x\f[R],\[u2006]\f[I]y\f[R]) or
(\f[I]x\f[R],\[u2006]\f[I]y\f[R],\[u2006]\f[I]z\f[R]) matching the
dimension the mesh.
If the keyword \f[C]DATA\f[R] is used, a new empty vector of the
appropriate size is defined.
The elements of this new vector can be assigned to the values of the
function at the \f[I]i\f[R]-th node or cell.
If the keyword \f[C]VECTOR\f[R] is used, the values of the dependent
variable are taken to be the values of the already-existing vector.
Note that this vector should have the size of the number of nodes or
cells the mesh has, depending on whether \f[C]NODES\f[R] or
\f[C]CELLS\f[R] is given.
If \f[C]VECTOR_DATA\f[R] is given, a set of
\f[I]n\f[R]\[u2005]+\[u2005]1 vectors of the same size is expected.
The first \f[I]n\f[R]\[u2005]+\[u2005]1 correspond to the arguments and
the last one is the function value.
Interpolation schemes can be given for either one or multi-dimensional
functions with \f[C]INTERPOLATION\f[R].
Available schemes for \f[I]n\f[R]\[u2004]=\[u2004]1 are:
.IP \[bu] 2
linear
.IP \[bu] 2
polynomial, the grade is equal to the number of data minus one
.IP \[bu] 2
spline, cubic (needs at least 3 points)
.IP \[bu] 2
spline_periodic
.IP \[bu] 2
akima (needs at least 5 points)
.IP \[bu] 2
akima_periodic (needs at least 5 points)
.IP \[bu] 2
steffen, always-monotonic splines-like (available only with GSL >= 2.0)
.PP
Default interpolation scheme for one-dimensional functions is
\f[C](*gsl_interp_linear)\f[R].
.PP
Available schemes for \f[I]n\f[R]\[u2004]>\[u2004]1 are:
.IP \[bu] 2
nearest, \f[I]f\f[R](\f[I]x\[u20D7]\f[R]) is equal to the value of the
closest definition point
.IP \[bu] 2
shepard, inverse distance weighted average definition
points (https://en.wikipedia.org/wiki/Inverse_distance_weighting) (might
lead to inefficient evaluation)
.IP \[bu] 2
shepard_kd, average of definition points within a
kd-tree (https://en.wikipedia.org/wiki/Inverse_distance_weighting#Modified_Shepard's_method)
(more efficient evaluation provided \f[C]SHEPARD_RADIUS\f[R] is set to a
proper value)
.IP \[bu] 2
bilinear, only available if the definition points configure an
structured hypercube-like grid.
If \f[I]n\f[R]\[u2004]>\[u2004]3, \f[C]SIZES\f[R] should be given.
.PP
For \f[I]n\f[R]\[u2004]>\[u2004]1, if the euclidean distance between the
arguments and the definition points is smaller than
\f[C]INTERPOLATION_THRESHOLD\f[R], the definition point is returned and
no interpolation is performed.
Default value is square root of \f[C]9.5367431640625e-07\f[R].
The initial radius of points to take into account in
\f[C]shepard_kd\f[R] is given by \f[C]SHEPARD_RADIUS\f[R].
If no points are found, the radius is double until at least one
definition point is found.
The radius is doubled until at least one point is found.
Default is \f[C]1.0\f[R].
The exponent of the \f[C]shepard\f[R] method is given by
\f[C]SHEPARD_EXPONENT\f[R].
Default is \f[C]2\f[R].
When requesting \f[C]bilinear\f[R] interpolation for
\f[I]n\f[R]\[u2004]>\[u2004]3, the number of definition points for each
argument variable has to be given with \f[C]SIZES\f[R], and wether the
definition data is sorted with the first argument changing first
(\f[C]X_INCREASES_FIRST\f[R] evaluating to non-zero) or with the last
argument changing first (zero).
The function can be pointwise-defined inline in the input using
\f[C]DATA\f[R].
This should be the last keyword of the line, followed by
\f[I]N\f[R]\[u2004]=\[u2004]\f[I]k\f[R]\[u2005]\[md]\[u2005](\f[I]n\f[R]\[u2005]+\[u2005]1)
expresions giving \f[I]k\f[R] definition points: \f[I]n\f[R] arguments
and the value of the function.
Multiline continuation using brackets \f[C]{\f[R] and \f[C]}\f[R] can be
used for a clean data organization.
See the examples.
.SS HISTORY
.RS
.PP
Record the time history of a variable as a function of time.
.RE
.IP
.nf
\f[C]
HISTORY <variable> <function>
\f[R]
.fi
.SS IF
.RS
.PP
Begin a conditional block.
.RE
.IP
.nf
\f[C]
IF expr
<block_of_instructions_if_expr_is_true>
[ ELSE ]
[block_of_instructions_if_expr_is_false]
ENDIF
\f[R]
.fi
.SS IMPLICIT
.RS
.PP
Define whether implicit declaration of variables is allowed or not.
.RE
.IP
.nf
\f[C]
IMPLICIT { NONE | ALLOWED }
\f[R]
.fi
.PP
By default, wasora allows variables (but not vectors nor matrices) to be
implicitly declared.
To avoid introducing errors due to typos, explicit declaration of
variables can be forced by giving \f[C]IMPLICIT NONE\f[R].
Whether implicit declaration is allowed or explicit declaration is
required depends on the last \f[C]IMPLICIT\f[R] keyword given, which by
default is \f[C]ALLOWED\f[R].
.SS INCLUDE
.RS
.PP
Include another wasora input file.
.RE
.IP
.nf
\f[C]
INCLUDE <file_path> [ FROM <num_expr> ] [ TO <num_expr> ]
\f[R]
.fi
.PP
Includes the input file located in the string \f[C]file_path\f[R] at the
current location.
The effect is the same as copying and pasting the contents of the
included file at the location of the \f[C]INCLUDE\f[R] keyword.
The path can be relative or absolute.
Note, however, that when including files inside \f[C]IF\f[R] blocks that
instructions are conditionally-executed but all definitions (such as
function definitions) are processed at parse-time independently from the
evaluation of the conditional.
The optional \f[C]FROM\f[R] and \f[C]TO\f[R] keywords can be used to
include only portions of a file.
.SS INITIAL_CONDITIONS_MODE
.RS
.PP
Define how initial conditions of DAE problems are computed.
.RE
.IP
.nf
\f[C]
INITIAL_CONDITIONS_MODE { AS_PROVIDED | FROM_VARIABLES | FROM_DERIVATIVES }
\f[R]
.fi
.PP
In DAE problems, initial conditions may be either:
.IP \[bu] 2
equal to the provided expressions (\f[C]AS_PROVIDED\f[R])
.IP \[bu] 2
the derivatives computed from the provided phase-space variables
(\f[C]FROM_VARIABLES\f[R])
.IP \[bu] 2
the phase-space variables computed from the provided derivatives
(\f[C]FROM_DERIVATIVES\f[R])
.PP
In the first case, it is up to the user to fulfill the DAE system
at\ \f[I]t\f[R]\[u2004]=\[u2004]0.
If the residuals are not small enough, a convergence error will occur.
The \f[C]FROM_VARIABLES\f[R] option means calling IDA\[cq]s
\f[C]IDACalcIC\f[R] routine with the parameter
\f[C]IDA_YA_YDP_INIT\f[R].
The \f[C]FROM_DERIVATIVES\f[R] option means calling IDA\[cq]s
\f[C]IDACalcIC\f[R] routine with the parameter IDA_Y_INIT.
Wasora should be able to automatically detect which variables in
phase-space are differential and which are purely algebraic.
However, the \f[C]DIFFERENTIAL\f[R] keyword may be used to explicitly
define them.
See the (SUNDIALS
documentation)[https://computation.llnl.gov/casc/sundials/documentation/ida_guide.pdf]
for further information.
.SS LOAD_PLUGIN
.RS
.PP
Load a wasora plug-in from a dynamic shared object.
.RE
.IP
.nf
\f[C]
LOAD_PLUGIN { <file_path> | <plugin_name> }
\f[R]
.fi
.PP
A wasora plugin in the form of a dynamic shared object
(i.e.\ \f[C].so\f[R]) can be loaded either with the
\f[C]LOAD_PLUGIN\f[R] keyword or from the command line with the
\f[C]-p\f[R] option.
Either a file path or a plugin name can be given.
The following locations are tried:
.IP \[bu] 2
the current directory \f[C]./\f[R]
.IP \[bu] 2
the parent directory \f[C]../\f[R]
.IP \[bu] 2
the user\[cq]s \f[C]LD_LIBRARY_PATH\f[R]
.IP \[bu] 2
the cache file \f[C]/etc/ld.so.cache\f[R]
.IP \[bu] 2
the directories \f[C]/lib\f[R], \f[C]/usr/lib\f[R],
\f[C]/usr/local/lib\f[R]
.PP
If a wasora plugin was compiled and installed following the
\f[C]make install\f[R] procedure, the plugin should be loaded by just
passing the name to \f[C]LOAD_PLUGIN\f[R].
.SS LOAD_ROUTINE
.RS
.PP
Load one or more routines from a dynamic shared object.
.RE
.IP
.nf
\f[C]
LOAD_ROUTINE <file_path> <routine_1> [ <routine_2> ... <routine_n> ]
\f[R]
.fi
.SS M4
.RS
.PP
Call the \f[C]m4\f[R] macro processor with definitions from wasora
variables or expressions.
.RE
.IP
.nf
\f[C]
M4 { INPUT_FILE <file_id> | FILE_PATH <file_path> } { OUTPUT_FILE <file_id> | OUTPUT_FILE_PATH <file_path> } [ EXPAND <name> ] ... } [ MACRO <name> [ <format> ] <definition> ] ... }
\f[R]
.fi
.SS MATRIX
.RS
.PP
Define a matrix.
.RE
.IP
.nf
\f[C]
MATRIX <name> ROWS <expr> COLS <expr> [ DATA num_expr_1 num_expr_2 ... num_expr_n ]
\f[R]
.fi
.SS MINIMIZE
.RS
.PP
Find the combination of arguments that give a (relative) minimum of a
function, i.e.\ run an optimization problem.
.RE
.IP
.nf
\f[C]
MINIMIZE <function> <function> [ METHOD { conjugate_fr | conjugate_pr | vector_bfgs2 | vector_bfgs | steepest_descent | nmsimplex2 | nmsimplex | nmsimplex2rand } [ GRADIENT <expr_1> <expr_2> ... <expr_n> ] [ GUESS <expr_1> <expr_2> ... <expr_n> ] [ MIN <expr_1> <expr_2> ... <expr_n> ] [ MAX <expr_1> <expr_2> ... <expr_n> ] [ STEP <expr_1> <expr_2> ... <expr_n> ] [ VERBOSE ] [ NORERUN ] [ MAX_ITER <expr> ] [ TOL <expr> ] [ GRADTOL <expr> ]
\f[R]
.fi
.SS PARAMETRIC
.RS
.PP
Systematically sweep a zone of the parameter space, i.e.\ perform a
parametric run.
.RE
.IP
.nf
\f[C]
PARAMETRIC <var_1> [ ... <var_n> ] [ TYPE { linear | logarithmic | random | gaussianrandom | sobol | niederreiter | halton | reversehalton } ] [ MIN <num_expr_1> ... <num_expr_n> ] [ MAX <num_expr_1> ... <num_expr_n> ] [ STEP <num_expr_1> ... <num_expr_n> ] [ NSTEPS <num_expr_1> ... <num_expr_n> ] [ OUTER_STEPS <num_expr> ] [ MAX_DAUGHTERS <num_expr> ] [ OFFSET <num_expr> ] [ ADIABATIC ]
\f[R]
.fi
.SS PHASE_SPACE
.RS
.PP
Define which variables, vectors and/or matrices belong to the phase
space of the DAE system to be solved.
.RE
.IP
.nf
\f[C]
PHASE_SPACE { <vars> | <vectors> | <matrices> }
\f[R]
.fi
.SS PRINT
.RS
.PP
Print plain-text and/or formatted data to the standard output or into an
output file.
.RE
.IP
.nf
\f[C]
PRINT [ FILE <file_id> | FILE_PATH <file_path> ] [ NONEWLINE ] [ SEP <string> ] [ NOSEP ] [ HEADER ] [ SKIP_STEP <expr> ] [ SKIP_STATIC_STEP <expr> ] [ SKIP_TIME <expr> ] [ SKIP_HEADER_STEP <expr> ] [ <object_1> <object_2> ... <object_n> ] [ TEXT <string_1> ... TEXT <string_n> ]
\f[R]
.fi
.PP
Each argument \f[C]object\f[R] that is not a keyword is expected to be
part of the output, can be either a matrix, a vector, an scalar
algebraic expression.
If the given object cannot be solved into a valid matrix, vector or
expression, it is treated as a string literal if \f[C]IMPLICIT\f[R] is
\f[C]ALLOWED\f[R], otherwise a parser error is raised.
To explicitly interpret an object as a literal string even if it
resolves to a valid numerical expression, it should be prefixed with the
\f[C]TEXT\f[R] keyword.
Hashes \f[C]#\f[R] appearing literal in text strings have to be quoted
to prevent the parser to treat them as comments within the wasora input
file and thus ignoring the rest of the line.
Whenever an argument starts with a porcentage sign \f[C]%\f[R], it is
treated as a C \f[C]printf\f[R]-compatible format definition and all the
objects that follow it are printed using the given format until a new
format definition is found.
The objects are treated as double-precision floating point numbers, so
only floating point formats should be given.
The default format is \f[C]\[dq]%g\[dq]\f[R].
Matrices, vectors, scalar expressions, format modifiers and string
literals can be given in any desired order, and are processed from left
to right.
Vectors are printed element-by-element in a single row.
See \f[C]PRINT_VECTOR\f[R] to print vectors column-wise.
Matrices are printed element-by-element in a single line using row-major
ordering if mixed with other objects but in the natural row and column
fashion if it is the only given object.
If the \f[C]FILE\f[R] keyword is not provided, default is to write to
stdout.
If the \f[C]NONEWLINE\f[R] keyword is not provided, default is to write
a newline \f[C]\[rs]n\f[R] character after all the objects are
processed.
The \f[C]SEP\f[R] keywords expects a string used to separate printed
objects, the default is a tab `DEFAULT_PRINT_SEPARATOR' character.
Use the \f[C]NOSEP\f[R] keyword to define an empty string as object
separator.
If the \f[C]HEADER\f[R] keyword is given, a single line containing the
literal text given for each object is printed at the very first time the
\f[C]PRINT\f[R] instruction is processed, starting with a hash
\f[C]#\f[R] character.
If the \f[C]SKIP_STEP\f[R] (\f[C]SKIP_STATIC_STEP\f[R])keyword is given,
the instruction is processed only every the number of transient (static)
steps that results in evaluating the expression, which may not be
constant.
By default the \f[C]PRINT\f[R] instruction is evaluated every step.
The \f[C]SKIP_HEADER_STEP\f[R] keyword works similarly for the optional
\f[C]HEADER\f[R] but by default it is only printed once.
The \f[C]SKIP_TIME\f[R] keyword use time advancements to choose how to
skip printing and may be useful for non-constant time-step problems.
.SS PRINT_FUNCTION
.RS
.PP
Print one or more functions as a table of values of dependent and
independent variables.
.RE
.IP
.nf
\f[C]
PRINT_FUNCTION <function_1> [ { function_2 | expr_1 } ... { function_n | expr_n-1 } ] [ FILE <file_id> | FILE_PATH <file_path> ] [ HEADER ] [ MIN <expr_1> <expr_2> ... <expr_m> ] [ MAX <expr_1> <expr_2> ... <expr_m> ] [ STEP <expr_1> <expr_2> ... <expr_m> ] [ NSTEPs <expr_1> <expr_2> ... <expr_m> ] [ FORMAT <print_format> ] [ PHYSICAL_ENTITY <name> ]
\f[R]
.fi
.SS PRINT_VECTOR
.RS
.PP
Print the elements of one or more vectors.
.RE
.IP
.nf
\f[C]
PRINT_VECTOR [ FILE <file_id> ] FILE_PATH <file_path> ] [ { VERTICAL | HORIZONTAL } ] [ ELEMS_PER_LINE <expr> ] [ FORMAT <print_format> ] <vector_1> [ vector_2 ... vector_n ]
\f[R]
.fi
.SS READ
.RS
.PP
Read data (variables, vectors o matrices) from files or shared-memory
segments.
.RE
.IP
.nf
\f[C]
[ READ | WRITE ] [ SHM <name> ] [ { ASCII_FILE_PATH | BINARY_FILE_PATH } <file_path> ] [ { ASCII_FILE | BINARY_FILE } <identifier> ] [ IGNORE_NULL ] [ object_1 object_2 ... object_n ]
\f[R]
.fi
.SS SEMAPHORE
.RS
.PP
Perform either a wait or a post operation on a named shared semaphore.
.RE
.IP
.nf
\f[C]
[ SEMAPHORE | SEM ] <name> { WAIT | POST }
\f[R]
.fi
.SS SHELL
.RS
.PP
Execute a shell command.
.RE
.IP
.nf
\f[C]
SHELL <print_format> [ expr_1 expr_2 ... expr_n ]
\f[R]
.fi
.SS SOLVE
.RS
.PP
Solve a non-linear system of\ \f[I]n\f[R] equations with\ \f[I]n\f[R]
unknowns.
.RE
.IP
.nf
\f[C]
SOLVE <n> UNKNOWNS <var_1> <var_2> ... <var_n> RESIDUALS <expr_1> <expr_2> ... <expr_n> ] GUESS <expr_1> <expr_2> ... <expr_n> ] [ METHOD { dnewton | hybrid | hybrids | broyden } ] [ EPSABS <expr> ] [ EPSREL <expr> ] [ MAX_ITER <expr> ] [ VERBOSE ]
\f[R]
.fi
.SS TIME_PATH
.RS
.PP
Force transient problems to pass through specific instants of time.
.RE
.IP
.nf
\f[C]
TIME_PATH <expr_1> [ <expr_2> [ ... <expr_n> ] ]
\f[R]
.fi
.PP
The time step \f[C]dt\f[R] will be reduced whenever the distance between
the current time \f[C]t\f[R] and the next expression in the list is
greater than \f[C]dt\f[R] so as to force \f[C]t\f[R] to coincide with
the expressions given.
The list of expresssions should evaluate to a sorted list of values.
.SS VAR
.RS
.PP
Define one or more scalar variables.
.RE
.IP
.nf
\f[C]
VAR <name_1> [ <name_2> ] ... [ <name_n> ]
\f[R]
.fi
.SS VECTOR
.RS
.PP
Define a vector.
.RE
.IP
.nf
\f[C]
VECTOR <name> SIZE <expr> [ DATA <expr_1> <expr_2> ... <expr_n> | FUNCTION_DATA <function> ]
\f[R]
.fi
.SS VECTOR_SORT
.RS
.PP
Sort the elements of a vector using a specific numerical order,
potentially making the same rearrangement of another vector.
.RE
.IP
.nf
\f[C]
VECTOR_SORT <vector> [ ASCENDING_ORDER | DESCENDING_ORDER ] [ <vector> ]
\f[R]
.fi
.SS WRITE
.RS
.PP
Write data (variables, vectors o matrices) to files or shared-memory
segments.
See the \f[C]READ\f[R] keyword for usage details.
.RE
.SS Mesh-related keywords
.SS MATERIAL
.RS
.IP
.nf
\f[C]
MATERIAL <name> [ MESH <name> ] [ PHYSICAL_GROUP <name_1> [ PHYSICAL_GROUP <name_2> [ ... ] ] ] [ <property_name_1> <expr_1> [ <property_name_2> <expr_2> [ ... ] ] ]
\f[R]
.fi
.RE
.SS MESH
.RS
.PP
Reads an unstructured mesh from an external file in MSH, VTK or FRD
format.
.RE
.IP
.nf
\f[C]
MESH [ NAME <name> ] { FILE <file_id> | FILE_PATH <file_path> } [ DIMENSIONS <num_expr> ]
 [ SCALE <expr> ] [ OFFSET <expr_x> <expr_y> <expr_z> ]
 [ READ_SCALAR <name_in_mesh> AS <function_name> ] .
 [ READ_FUNCTION <function_name> ] .
\f[R]
.fi
.PP
If there will be only one mesh in the input file, the \f[C]NAME\f[R] is
optional.
Yet it might be needed in cases where there are many meshes and one
needs to refer to a particular mesh, such as in \f[C]MESH_POST\f[R] or
\f[C]MESH_INTEGRATE\f[R].
When solving PDEs (such as in Fino or milonga), the first mesh is the
problem mesh.
Either a file identifier (defined previously with a \f[C]FILE\f[R]
keyword) or a file path should be given.
The format is read from the extension, which should be either
.IP \[bu] 2
\f[C].msh\f[R] Gmsh ASCII
format (http://gmsh.info/doc/texinfo/gmsh.html#MSH-file-format),
versions 2.2, 4.0 or 4.1
.IP \[bu] 2
\f[C].vtk\f[R] ASCII legacy
VTK (https://lorensen.github.io/VTKExamples/site/VTKFileFormats/)
.IP \[bu] 2
\f[C].frd\f[R] CalculiX\[cq]s FRD ASCII
output (https://web.mit.edu/calculix_v2.7/CalculiX/cgx_2.7/doc/cgx/node4.html))
.PP
Note than only MSH is suitable for defining PDE domains, as it is the
only one that provides information about physical groups.
The spatial dimensions should be given with \f[C]DIMENSION\f[R].
If material properties are uniform and given with variables, the
dimensions are not needed and will be read from the file.
But if spatial functions are needed (either for properties or read from
the mesh file), an explicit value for the mesh dimensions is needed.
If either \f[C]SCALE\f[R] or \f[C]OFFSET\f[R] are given, the node
position if first shifted and then scaled by the provided amounts.
For each \f[C]READ_SCALAR\f[R] keyword, a point-wise defined function of
space named \f[C]<function_name>\f[R] is defined and filled with the
scalar data named \f[C]<name_in_mesh>\f[R] contained in the mesh file.
The \f[C]READ_FUNCTION\f[R] keyword is a shortcut when the scalar name
and the to-be-defined function are the same.
If no \f[C]NAME\f[R] is given, the first mesh to be defined is called
\f[C]first\f[R].
.SS MESH_FILL_VECTOR
.RS
.PP
Fills the elements of a vector with data evaluated at the nodes or the
cells of a mesh.
.RE
.IP
.nf
\f[C]
MESH_FILL_VECTOR VECTOR <vector> { FUNCTION <function> | EXPRESSION <expr> } 
 [ MESH <name> ] [ NODES | CELLS ]
\f[R]
.fi
.PP
The vector to be filled needs to be already defined and to have the
appropriate size, either the number of nodes or cells of the mesh
depending on \f[C]NODES\f[R] or \f[C]CELLS\f[R] (default is nodes).
The elements of the vectors will be either the \f[C]FUNCTION\f[R] or the
\f[C]EXPRESSION\f[R] of \f[I]x\f[R], \f[I]y\f[R] and \f[I]z\f[R]
evaluated at the nodes or cells of the provided mesh.
If there is more than one mesh, the name has to be given.
.SS MESH_FIND_MINMAX
.RS
.PP
Finds absolute extrema of a function or expression within a mesh-based
domain.
.RE
.IP
.nf
\f[C]
MESH_FIND_MINMAX { FUNCTION <function> | EXPRESSION <expr> }
 [ MESH <name> ] [ OVER <physical_group_name> ] [ NODES | CELLS ]
 [ MIN <variable> ] [ MAX <variable> ]
 [ X_MIN <variable> ] [ Y_MIN <variable> ] [ Z_MIN <variable> ] [ I_MIN <variable> ]
 [ X_MAX <variable> ] [ Y_MAX <variable> ] [ Z_MAX <variable> ] [ I_MAX <variable> ]
\f[R]
.fi
.PP
Either a \f[C]FUNCTION\f[R] or an \f[C]EXPRESSION\f[R] should be given.
In the first case, just the function name is expected (i.e.\ not its
arguments).
In the second case, a full algebraic expression including the arguments
is expected.
If no explicit mesh is provided, the main mesh is used to search for the
extrema.
If the \f[C]OVER\f[R] keyword is given, the search is performed only on
the provided physical group.
Depending on the problem type, it might be needed to switch from
\f[C]NODES\f[R] to \f[C]CELLS\f[R] but this is usually not needed.
If given, the minimum (maximum) value is stored in the variable provided
by the \f[C]MIN\f[R] (\f[C]MAX\f[R]) keyword.
If given, the \f[I]x\f[R] (or \f[I]y\f[R] or \f[I]z\f[R]) coordinate of
the minimum (maximum) value is stored in the variable provided by the
\f[C]X_MIN\f[R] (or \f[C]Y_MIN\f[R] or \f[C]Z_MIN\f[R])
(\f[C]X_MAX\f[R], \f[C]Y_MAX\f[R], \f[C]Z_MAX\f[R]) keyword.
If given, the index of the minimum (maximum) value (i.e.\ the node or
cell number) is stored in the variable provided by the \f[C]I_MIN\f[R]
(\f[C]I_MAX\f[R]) keyword.
.SS MESH_INTEGRATE
.RS
.PP
Performs a spatial integration of a function or expression over a mesh.
.RE
.IP
.nf
\f[C]
MESH_INTEGRATE { FUNCTION <function> | EXPRESSION <expr> }
 [ MESH <mesh_identifier> ] [ OVER <physical_group> ] [ NODES | CELLS ]
 RESULT <variable>
\f[R]
.fi
.PP
The integrand may be either a \f[C]FUNCTION\f[R] or an
\f[C]EXPRESSION\f[R].
In the first case, just the function name is expected (i.e.\ not its
arguments).
In the second case, a full algebraic expression including the arguments
is expected.
If the expression is just \f[C]1\f[R] then the volume (or area or
length) of the domain is computed.
Note that arguments ought to be \f[C]x\f[R], \f[C]y\f[R] and/or
\f[C]z\f[R].
If there are more than one mesh defined, an explicit one has to be given
with \f[C]MESH\f[R].
By default the integration is performed over the highest-dimensional
elements of the mesh.
If the integration is to be carried out over just a physical group, it
has to be given in \f[C]OVER\f[R].
Either \f[C]NODES\f[R] or \f[C]CELLS\f[R] define how the integration is
to be performed.
In the first case a the integration is performed using the Gauss points
and weights associated to each element type.
In the second case, the integral is computed as the sum of the product
of the function evaluated at the center of each cell (element) and the
cell\[cq]s volume.
The scalar result of the integration is stored in the variable given by
\f[C]RESULT\f[R].
If the variable does not exist, it is created.
.SS MESH_MAIN
.RS
.IP
.nf
\f[C]
MESH_MAIN [ <name> ]
\f[R]
.fi
.RE
.SS MESH_POST
.RS
.IP
.nf
\f[C]
MESH_POST [ MESH <mesh_identifier> ] { FILE <name> | FILE_PATH <file_path> } [ NO_MESH ] [ FORMAT { gmsh | vtk } ] [ CELLS | ] NODES ] [ NO_PHYSICAL_NAMES ] [ VECTOR <function1_x> <function1_y> <function1_z> ] . [ <scalar_function_1> ] [ <scalar_function_2> ] ...
\f[R]
.fi
.RE
.SS PHYSICAL_GROUP
.RS
.PP
Defines a physical group of elements within a mesh file.
.RE
.IP
.nf
\f[C]
PHYSICAL_GROUP <name> [ MESH <name> ] [ DIMENSION <expr> ]
 [ MATERIAL <name> ]
 [ BC <bc_1> <bc_2> ... ]
\f[R]
.fi
.PP
A name is mandatory for each physical group defined within the input
file.
If there is no physical group with the provided name in the mesh, this
instruction makes no effect.
If there are many meshes, an explicit mesh can be given with
\f[C]MESH\f[R].
Otherwise, the physical group is defined on the main mesh.
An explicit dimension of the physical group can be provided with
\f[C]DIMENSION\f[R].
For volumetric elements, physical groups can be linked to materials
using \f[C]MATERIAL\f[R].
Note that if a material is created with the same name as a physical
group in the mesh, they will be linked automatically.
The \f[C]MATERIAL\f[R] keyword in \f[C]PHYSICAL_GROUP\f[R] is used to
link a physical group in a mesh file and a material in the wasora input
file with different names.
For non-volumetric elements, boundary conditions can be assigned by
using the \f[C]BC\f[R] keyword.
This should be the last keyword of the line, and any token afterwards is
treated specially by the underlying solver (i.e.\ Fino or milonga).
.SS PHYSICAL_PROPERTY
.RS
.IP
.nf
\f[C]
PHYSICAL_PROPERTY <name> [ <material_name1> <expr1> [ <material_name2> <expr2> ] ... ]
\f[R]
.fi
.RE
.SS Variables
.SS done
.RS
.PP
Flag that indicates whether the overall calculation is over.
.RE
.SS done_outer
.RS
.PP
Flag that indicates whether the parametric, optimization of fit
calculation is over or not.
It is set to true (i.e.\ \[u2004]\[!=]\[u2004]0) by wasora whenever the
outer calculation is considered to be finished, which can be that the
parametric calculation swept the desired parameter space or that the
optimization algorithm reached the desired convergence criteria.
If the user sets it to true, the current step is marked as the last
outer step and the transient calculation ends after finishing the step.
.RE
.SS done_static
.RS
.PP
Flag that indicates whether the static calculation is over or not.
It is set to true (i.e.\ \[u2004]\[!=]\[u2004]0) by wasora if
\f[C]step_static\f[R] \[>=] \f[C]static_steps\f[R].
If the user sets it to true, the current step is marked as the last
static step and the static calculation ends after finishing the step.
.RE
.SS done_transient
.RS
.PP
Flag that indicates whether the transient calculation is over or not.
It is set to true (i.e.\ \[u2004]\[!=]\[u2004]0) by wasora if
\f[C]t\f[R] \[>=] \f[C]end_time\f[R].
If the user sets it to true, the current step is marked as the last
transient step and the transient calculation ends after finishing the
step.
.RE
.SS dt
.RS
.PP
Actual value of the time step for transient calculations.
When solving DAE systems, this variable is set by wasora.
It can be written by the user for example by importing it from another
transient code by means of shared-memory objects.
Care should be taken when solving DAE systems and overwriting
\f[C]t\f[R].
Default value is 1/16, which is a power of two and roundoff errors are
thus reduced.
.RE
.SS end_time
.RS
.PP
Final time of the transient calculation, to be set by the user.
The default value is zero, meaning no transient calculation.
.RE
.SS i
.RS
.PP
Dummy index, used mainly in vector and matrix row subindex expressions.
.RE
.SS infinite
.RS
.PP
A very big positive number, which can be used as
\f[C]end_time = infinite\f[R] or to define improper integrals with
infinite limits.
Default is 2^50^\[u2004]\[~=]\[u2004]1\[u2005]\[tmu]\[u2005]10^15^.
.RE
.SS in_outer_initial
.RS
.PP
Flag that indicates if the current step is the initial step of an
optimization of fit run.
.RE
.SS in_static
.RS
.PP
Flag that indicates if wasora is solving the iterative static
calculation.
Flag that indicates if wasora is in the first step of the iterative
static calculation.
Flag that indicates if wasora is in the last step of the iterative
static calculation.
.RE
.SS in_transient
.RS
.PP
Flag that indicates if wasora is solving transient calculation.
.RE
.SS in_transient_first
.RS
.PP
Flag that indicates if wasora is in the first step of the transient
calculation.
.RE
.SS in_transient_last
.RS
.PP
Flag that indicates if wasora is in the last step of the transient
calculation.
.RE
.SS j
.RS
.PP
Dummy index, used mainly in matrix column subindex expressions.
.RE
.SS max_dt
.RS
.PP
Maximum bound for the time step that wasora should take when solving DAE
systems.
.RE
.SS min_dt
.RS
.PP
Minimum bound for the time step that wasora should take when solving DAE
systems.
.RE
.SS ncores
.RS
.PP
The number of online available cores, as returned by
\f[C]sysconf(_SC_NPROCESSORS_ONLN)\f[R].
This value can be used in the \f[C]MAX_DAUGHTERS\f[R] expression of the
\f[C]PARAMETRIC\f[R] keyword (i.e \f[C]ncores/2\f[R]).
.RE
.SS on_gsl_error
.RS
.PP
This should be set to a mask that indicates how to proceed if an error
ir raised in any routine of the GNU Scientific Library.
.RE
.SS on_ida_error
.RS
.PP
This should be set to a mask that indicates how to proceed if an error
ir raised in any routine of the SUNDIALS IDA Library.
.RE
.SS on_nan
.RS
.PP
This should be set to a mask that indicates how to proceed if
Not-A-Number signal (such as a division by zero) is generated when
evaluating any expression within wasora.
.RE
.SS pi
.RS
.PP
A double-precision floating point representaion of the number
\f[I]\[*p]\f[R], equal to \f[C]math.h\f[R] \[cq]s \f[C]M_PI\f[R]
constant.
.RE
.SS pid
.RS
.PP
The UNIX process id of wasora (or the plugin).
.RE
.SS realtime_scale
.RS
.PP
If this variable is not zero, then the transient problem is run trying
to syncrhonize the problem time with realtime, up to a scale given.
For example, if the scale is set to one, then wasora will advance the
problem time at the same pace that the real wall time advances.
If set to two, wasora\[cq]s time wil advance twice as fast as real time,
and so on.
If the calculation time is slower than real time modified by the scale,
this variable has no effect on the overall behavior and execution will
proceed as quick as possible with no delays.
.RE
.SS rel_error
.RS
.PP
Maximum allowed relative error for the solution of DAE systems.
Default value is is 1\[u2005]\[tmu]\[u2005]10^\[u2005]\[mi]\[u2005]6^.
If a fine per-variable error control is needed, special vector
\f[C]abs_error\f[R] should be used.
.RE
.SS static_steps
.RS
.PP
Number of steps that ought to be taken during the static calculation, to
be set by the user.
The default value is one, meaning only one static step.
.RE
.SS step_outer
.RS
.PP
Indicates the current step number of the iterative outer calculation
(parametric, optimization or fit).
Indicates the current step number of the iterative inner calculation
(optimization or fit).
.RE
.SS step_static
.RS
.PP
Indicates the current step number of the iterative static calculation.
.RE
.SS step_transient
.RS
.PP
Indicates the current step number of the transient static calculation.
.RE
.SS t
.RS
.PP
Actual value of the time for transient calculations.
This variable is set by wasora, but can be written by the user for
example by importing it from another transient code by means of
shared-memory objects.
Care should be taken when solving DAE systems and overwriting
\f[C]t\f[R].
.RE
.SS zero
.RS
.PP
A very small positive number, which is taken to avoid roundoff errors
when comparing floating point numbers such as replacing
\f[I]a\f[R]\[u2004]\[<=]\[u2004]\f[I]a\f[R]~max~ with
\f[I]a\f[R]\[u2004]<\[u2004]\f[I]a\f[R]~max~+ \f[C]zero\f[R].
Default is
(1/2)^\[u2005]\[mi]\[u2005]50^\[u2004]\[~=]\[u2004]9\[u2005]\[tmu]\[u2005]10^\[u2005]\[mi]\[u2005]16^
\&.
.RE
.SS Mesh-related variables
.SS bbox_min
.RS
.PP
Minimum values of the mesh\[cq]s bounding box (vector of size 3) Maximum
values of the mesh\[cq]s bounding box (vector of size 3)
.RE
.SS cells
.RS
.PP
Number of cells of the unstructured grid.
This number is the actual quantity of volumetric elements in which the
domain was discretized.
.RE
.SS elements
.RS
.PP
Number of total elements of the unstructured grid.
This number include those surface elements that belong to boundary
physical entities.
.RE
.SS nodes
.RS
.PP
Number of nodes of the unstructured grid.
.RE
.SS Functions
.SS abs
.RS
.PP
Returns the absolute value of the argument \f[I]x\f[R].
.RE
.IP
.nf
\f[C]
y = abs(x)
\f[R]
.fi
.SS acos
.RS
.PP
Computes arc in radians whose cosine is equal to the argument
\f[I]x\f[R].
A NaN error is raised if |\f[I]x\f[R]|\[u2004]>\[u2004]1.
.RE
.IP
.nf
\f[C]
y = acos(x)
\f[R]
.fi
.SS asin
.RS
.PP
Computes arc in radians whose sine is equal to the argument \f[I]x\f[R].
A NaN error is raised if |\f[I]x\f[R]|\[u2004]>\[u2004]1.
.RE
.IP
.nf
\f[C]
y = asin(x)
\f[R]
.fi
.SS atan
.RS
.PP
Computes, in radians, the arc tangent of the argument \f[I]x\f[R].
.RE
.IP
.nf
\f[C]
atan(x)
\f[R]
.fi
.SS atan2
.RS
.PP
Computes, in radians, the arc tangent of quotient
\f[I]y\f[R]/\f[I]x\f[R], using the signs of the two arguments to
determine the quadrant of the result, which is in the range
[\[u2005]\[mi]\[u2005]\f[I]\[*p]\f[R],\[u2006]\f[I]\[*p]\f[R]].
.RE
.IP
.nf
\f[C]
atan(y,x)
\f[R]
.fi
.SS ceil
.RS
.PP
Returns the smallest integral value not less than the argument
\f[I]x\f[R].
.RE
.IP
.nf
\f[C]
ceil(x)
\f[R]
.fi
.SS clock
.RS
.PP
Returns the value of a certain clock in seconds measured from a certain
(but specific) milestone.
The kind of clock and the initial milestone depends on the optional flag
\f[I]f\f[R].
It defaults to zero, meaning wall time since the UNIX Epoch.
The list and the meanings of the other available values for \f[I]f\f[R]
can be checked in the \f[C]clock_gettime (2)\f[R] system call manual
page.
.RE
.IP
.nf
\f[C]
clock([f])
\f[R]
.fi
.SS cos
.RS
.PP
Computes the cosine of the argument \f[I]x\f[R], where \f[I]x\f[R] is in
radians.
A cosine wave can be generated by passing as the argument \f[I]x\f[R] a
linear function of time such as
\f[I]\[*w]\f[R]\f[I]t\f[R]\[u2005]+\[u2005]\f[I]\[*f]\f[R], where
\f[I]\[*w]\f[R] controls the frequency of the wave and \f[I]\[*f]\f[R]
controls its phase.
.RE
.IP
.nf
\f[C]
cos(x)
\f[R]
.fi
.SS cosh
.RS
.PP
Computes the hyperbolic cosine of the argument \f[I]x\f[R], where
\f[I]x\f[R] is in radians.
.RE
.IP
.nf
\f[C]
cosh(x)
\f[R]
.fi
.SS d_dt
.RS
.PP
Computes the time derivative of the signal \f[I]x\f[R] using the
difference between the value of the signal in the previous time step and
the actual value divided by the time step.
For \f[I]t\f[R]\[u2004]=\[u2004]0, the return value is zero.
Unlike the functional \f[C]derivative\f[R], this function works with
expressions and not with functions.
Therefore the argument \f[I]x\f[R] may be for example an expression
involving a variable that may be read from a shared-memory object, whose
time derivative cannot be computed with \f[C]derivative\f[R].
.RE
.IP
.nf
\f[C]
d_dt(x)
\f[R]
.fi
.SS deadband
.RS
.PP
Filters the first argument \f[I]x\f[R] with a deadband centered at zero
with an amplitude given by the second argument \f[I]a\f[R].
.RE
.IP
.nf
\f[C]
deadband(x, a)
\f[R]
.fi
.SS equal
.RS
.PP
Checks if the two first expressions \f[I]a\f[R] and \f[I]b\f[R] are
equal, up to the tolerance given by the third optional argument
\f[I]\[+e]\f[R].
If either |\f[I]a\f[R]|\[u2004]>\[u2004]1 or
|\f[I]b\f[R]|\[u2004]>\[u2004]1, the arguments are compared using
GSL\[cq]s \f[C]gsl_fcmp\f[R], otherwise the absolute value of their
difference is compared against \f[I]\[+e]\f[R].
This function returns zero if the arguments are not equal and one
otherwise.
Default value for
\f[I]\[+e]\f[R]\[u2004]=\[u2004]10^\[u2005]\[mi]\[u2005]16^.
.RE
.IP
.nf
\f[C]
equal(a, b, [eps])
\f[R]
.fi
.SS exp
.RS
.PP
Computes the exponential function the argument \f[I]x\f[R], i.e.\ the
base of the natural logarithms raised to the \f[I]x\f[R]-th power.
.RE
.IP
.nf
\f[C]
exp(x)
\f[R]
.fi
.SS expint1
.RS
.PP
Computes the first exponential integral function of the argument
\f[I]x\f[R].
If \f[I]x\f[R] equals zero, a NaN error is issued.
.RE
.IP
.nf
\f[C]
expint1(x)
\f[R]
.fi
.SS expint2
.RS
.PP
Computes the second exponential integral function of the argument
\f[I]x\f[R].
.RE
.IP
.nf
\f[C]
expint2(x)
\f[R]
.fi
.SS expint3
.RS
.PP
Computes the third exponential integral function of the argument
\f[I]x\f[R].
.RE
.IP
.nf
\f[C]
expint3(x)
\f[R]
.fi
.SS expintn
.RS
.PP
Computes the \f[I]n\f[R]-th exponential integral function of the
argument \f[I]x\f[R].
If \f[I]n\f[R] equals zero or one and \f[I]x\f[R] zero, a NaN error is
issued.
.RE
.IP
.nf
\f[C]
expintn(n,x)
\f[R]
.fi
.SS floor
.RS
.PP
Returns the largest integral value not greater than the argument
\f[I]x\f[R].
.RE
.IP
.nf
\f[C]
floor(x)
\f[R]
.fi
.SS heaviside
.RS
.PP
Computes the zero-centered Heaviside step function of the argument
\f[I]x\f[R].
If the optional second argument \f[I]\[+e]\f[R] is provided, the
discontinuous step at \f[I]x\f[R]\[u2004]=\[u2004]0 is replaced by a
ramp starting at \f[I]x\f[R]\[u2004]=\[u2004]0 and finishing at
\f[I]x\f[R]\[u2004]=\[u2004]\f[I]\[+e]\f[R].
.RE
.IP
.nf
\f[C]
heaviside(x, [eps])
\f[R]
.fi
.SS if
.RS
.PP
Performs a conditional testing of the first argument \f[I]a\f[R], and
returns either the second optional argument \f[I]b\f[R] if \f[I]a\f[R]
is different from zero or the third optional argument \f[I]c\f[R] if
\f[I]a\f[R] evaluates to zero.
The comparison of the condition \f[I]a\f[R] with zero is performed
within the precision given by the optional fourth argument
\f[I]\[+e]\f[R].
If the second argument \f[I]c\f[R] is not given and \f[I]a\f[R] is not
zero, the function returns one.
If the third argument \f[I]c\f[R] is not given and \f[I]a\f[R] is zero,
the function returns zero.
The default precision is
\f[I]\[+e]\f[R]\[u2004]=\[u2004]10^\[u2005]\[mi]\[u2005]16^.
Even though \f[C]if\f[R] is a logical operation, all the arguments and
the returned value are double-precision floating point numbers.
.RE
.IP
.nf
\f[C]
if(a, [b], [c], [eps])
\f[R]
.fi
.SS integral_dt
.RS
.PP
Computes the time integral of the signal \f[I]x\f[R] using the
trapezoidal rule using the value of the signal in the previous time step
and the current value.
At \f[I]t\f[R]\[u2004]=\[u2004]0 the integral is initialized to zero.
Unlike the functional \f[C]integral\f[R], this function works with
expressions and not with functions.
Therefore the argument \f[I]x\f[R] may be for example an expression
involving a variable that may be read from a shared-memory object, whose
time integral cannot be computed with \f[C]integral\f[R].
.RE
.IP
.nf
\f[C]
integral_dt(x)
\f[R]
.fi
.SS integral_euler_dt
.RS
.PP
Idem as \f[C]integral_dt\f[R] but uses the backward Euler rule to update
the integral value.
This function is provided in case this particular way of approximating
time integrals is needed.
.RE
.IP
.nf
\f[C]
integral_euler_dt(x)
\f[R]
.fi
.SS is_even
.RS
.PP
Returns one if the argument \f[I]x\f[R] rounded to the nearest integer
is even.
.RE
.IP
.nf
\f[C]
y = is_even(x)
\f[R]
.fi
.SS is_in_interval
.RS
.PP
Returns true if the argument\[ti]\f[I]x\f[R] is in the
interval\[ti][\f[I]a\f[R],\[u2006]\f[I]b\f[R]),
i.e.\ including\[ti]\f[I]a\f[R] but excluding\[ti]\f[I]b\f[R].
.RE
.IP
.nf
\f[C]
is_in_interval(x, a, b)
\f[R]
.fi
.SS is_odd
.RS
.PP
Returns one if the argument \f[I]x\f[R] rounded to the nearest integer
is odd.
.RE
.IP
.nf
\f[C]
y = is_odd(x)
\f[R]
.fi
.SS j0
.RS
.PP
Computes the regular cylindrical Bessel function of zeroth order
evaluated at the argument \f[I]x\f[R].
.RE
.IP
.nf
\f[C]
j0(x)
\f[R]
.fi
.SS lag
.RS
.PP
Filters the first argument \f[I]x\f[R](\f[I]t\f[R]) with a first-order
lag of characteristic time \f[I]\[*t]\f[R], i.e.\ this function applies
the transfer function !bt [ G(s) = ] !et to the time-dependent signal
\f[I]x\f[R](\f[I]t\f[R]), by assuming that it is constant during the
time interval
[\f[I]t\f[R]\[u2005]\[mi]\[u2005]\f[I]\[*D]\f[R]\f[I]t\f[R],\[u2006]\f[I]t\f[R]]
and using the analytical solution of the differential equation for that
case at \f[I]t\f[R]\[u2004]=\[u2004]\f[I]\[*D]\f[R]\f[I]t\f[R] with the
initial condition
\f[I]y\f[R](0)\[u2004]=\[u2004]\f[I]y\f[R](\f[I]t\f[R]\[u2005]\[mi]\[u2005]\f[I]\[*D]\f[R]\f[I]t\f[R]).
.RE
.IP
.nf
\f[C]
lag(x, tau)
\f[R]
.fi
.SS lag_bilinear
.RS
.PP
Filters the first argument \f[I]x\f[R](\f[I]t\f[R]) with a first-order
lag of characteristic time \f[I]\[*t]\f[R], i.e.\ this function applies
the transfer function !bt [ G(s) = ] !et to the time-dependent signal
\f[I]x\f[R](\f[I]t\f[R]) by using the bilinear transformation formula.
.RE
.IP
.nf
\f[C]
lag_bilinear(x, tau)
\f[R]
.fi
.SS lag_euler
.RS
.PP
Filters the first argument \f[I]x\f[R](\f[I]t\f[R]) with a first-order
lag of characteristic time \f[I]\[*t]\f[R], i.e.\ this function applies
the transfer function !bt [ G(s) = ] !et to the time-dependent signal
\f[I]x\f[R](\f[I]t\f[R]) by using the Euler forward rule.
.RE
.IP
.nf
\f[C]
lag_euler(x, tau)
\f[R]
.fi
.SS last
.RS
.PP
Returns the value the signal \f[I]x\f[R] had in the previous time step.
This function is equivalent to the \f[I]Z\f[R]-transform operator
\[lq]delay\[rq] denoted by
\f[I]z\f[R]^\[u2005]\[mi]\[u2005]1^[\f[I]x\f[R]].
For \f[I]t\f[R]\[u2004]=\[u2004]0 the function returns the actual value
of \f[I]x\f[R].
The optional flag \f[I]p\f[R] should be set to one if the reference to
\f[C]last\f[R] is done in an assignment over a variable that already
appears insi expression \f[I]x\f[R].
See example number 2.
.RE
.IP
.nf
\f[C]
last(x,[p])
\f[R]
.fi
.SS limit
.RS
.PP
Limits the first argument \f[I]x\f[R] to the interval
[\f[I]a\f[R],\[u2006]\f[I]b\f[R]].
The second argument \f[I]a\f[R] should be less than the third argument
\f[I]b\f[R].
.RE
.IP
.nf
\f[C]
limit(x, a, b)
\f[R]
.fi
.SS limit_dt
.RS
.PP
Limits the value of the first argument \f[I]x\f[R](\f[I]t\f[R]) so to
that its time derivative is bounded to the interval
[\f[I]a\f[R],\[u2006]\f[I]b\f[R]].
The second argument \f[I]a\f[R] should be less than the third argument
\f[I]b\f[R].
.RE
.IP
.nf
\f[C]
limit_dt(x, a, b)
\f[R]
.fi
.SS log
.RS
.PP
Computes the natural logarithm of the argument \f[I]x\f[R].
If \f[I]x\f[R] is zero or negative, a NaN error is issued.
.RE
.IP
.nf
\f[C]
log(x)
\f[R]
.fi
.SS mark_max
.RS
.PP
Returns the integer index \f[I]i\f[R] of the maximum of the arguments
\f[I]x\f[R]~\f[I]i\f[R]~ provided.
Currently only maximum of ten arguments can be provided.
.RE
.IP
.nf
\f[C]
mark_max(x1, x2, ., [x10])
\f[R]
.fi
.SS mark_min
.RS
.PP
Returns the integer index \f[I]i\f[R] of the minimum of the arguments
\f[I]x\f[R]~\f[I]i\f[R]~ provided.
Currently only maximum of ten arguments can be provided.
.RE
.IP
.nf
\f[C]
mark_max(x1, x2, ., [x10])
\f[R]
.fi
.SS max
.RS
.PP
Returns the maximum of the arguments \f[I]x\f[R]~\f[I]i\f[R]~ provided.
Currently only maximum of ten arguments can be provided.
.RE
.IP
.nf
\f[C]
max(x1, x2, ., [x10])
\f[R]
.fi
.SS min
.RS
.PP
Returns the minimum of the arguments \f[I]x\f[R]~\f[I]i\f[R]~ provided.
Currently only maximum of ten arguments can be provided.
.RE
.IP
.nf
\f[C]
min(x1, x2, ., [x10])
\f[R]
.fi
.SS mod
.RS
.PP
Returns the remainder of the division between the first argument
\f[I]a\f[R] and the second \f[I]b\f[R].
Both arguments may be non-integral.
.RE
.IP
.nf
\f[C]
mod(a, b)
\f[R]
.fi
.SS not
.RS
.PP
Returns one if the first argument \f[I]x\f[R] is zero and zero
otherwise.
The second optional argument \f[I]\[+e]\f[R] gives the precision of the
\[lq]zero\[rq] evaluation.
If not given, default is
\f[I]\[+e]\f[R]\[u2004]=\[u2004]10^\[u2005]\[mi]\[u2005]16^.
.RE
.IP
.nf
\f[C]
not(x, [eps])
\f[R]
.fi
.SS random
.RS
.PP
Returns a random real number uniformly distributed between the first
real argument \f[I]x\f[R]~1~ and the second one \f[I]x\f[R]~2~.
If the third integer argument \f[I]s\f[R] is given, it is used as the
seed and thus repetitive sequences can be obtained.
If no seed is provided, the current time (in seconds) plus the internal
address of the expression is used.
Therefore, two successive calls to the function without seed (hopefully)
do not give the same result.
This function uses a second-order multiple recursive generator described
by Knuth in Seminumerical Algorithms, 3rd Ed., Section 3.6.
.RE
.IP
.nf
\f[C]
random(x1, x2, [s])
\f[R]
.fi
.SS random_gauss
.RS
.PP
Returns a random real number with a Gaussian distribution with a mean
equal to the first argument \f[I]x\f[R]~1~ and a standard deviation
equatl to the second one \f[I]x\f[R]~2~.
If the third integer argument \f[I]s\f[R] is given, it is used as the
seed and thus repetitive sequences can be obtained.
If no seed is provided, the current time (in seconds) plus the internal
address of the expression is used.
Therefore, two successive calls to the function without seed (hopefully)
do not give the same result.
This function uses a second-order multiple recursive generator described
by Knuth in Seminumerical Algorithms, 3rd Ed., Section 3.6.
.RE
.IP
.nf
\f[C]
random_gauss(x1, x2, [s])
\f[R]
.fi
.SS round
.RS
.PP
Rounds the argument \f[I]x\f[R] to the nearest integer.
Halfway cases are rounded away from zero.
.RE
.IP
.nf
\f[C]
round(x)
\f[R]
.fi
.SS sawtooth_wave
.RS
.PP
Computes a sawtooth wave betwen zero and one with a period equal to one.
As with the sine wave, a sawtooh wave can be generated by passing as the
argument \f[I]x\f[R] a linear function of time such as
\f[I]\[*w]\f[R]\f[I]t\f[R]\[u2005]+\[u2005]\f[I]\[*f]\f[R], where
\f[I]\[*w]\f[R] controls the frequency of the wave and \f[I]\[*f]\f[R]
controls its phase.
.RE
.IP
.nf
\f[C]
sawtooth_wave(x)
\f[R]
.fi
.SS sgn
.RS
.PP
Returns minus one, zero or plus one depending on the sign of the first
argument \f[I]x\f[R].
The second optional argument \f[I]\[+e]\f[R] gives the precision of the
\[lq]zero\[rq] evaluation.
If not given, default is
\f[I]\[+e]\f[R]\[u2004]=\[u2004]10^\[u2005]\[mi]\[u2005]16^.
.RE
.IP
.nf
\f[C]
sgn(x, [eps])
\f[R]
.fi
.SS sin
.RS
.PP
Computes the sine of the argument \f[I]x\f[R], where \f[I]x\f[R] is in
radians.
A sine wave can be generated by passing as the argument \f[I]x\f[R] a
linear function of time such as
\f[I]\[*w]\f[R]\f[I]t\f[R]\[u2005]+\[u2005]\f[I]\[*f]\f[R], where
\f[I]\[*w]\f[R] controls the frequency of the wave and \f[I]\[*f]\f[R]
controls its phase.
.RE
.IP
.nf
\f[C]
sin(x)
\f[R]
.fi
.SS sinh
.RS
.PP
Computes the hyperbolic sine of the argument \f[I]x\f[R], where
\f[I]x\f[R] is in radians.
.RE
.IP
.nf
\f[C]
sinh(x)
\f[R]
.fi
.SS sqrt
.RS
.PP
Computes the positive square root of the argument \f[I]x\f[R].
If \f[I]x\f[R] is negative, a NaN error is issued.
.RE
.IP
.nf
\f[C]
sqrt(x)
\f[R]
.fi
.SS square_wave
.RS
.PP
Computes a square function betwen zero and one with a period equal to
one.
The output is one for 0\[u2004]<\[u2004]\f[I]x\f[R]\[u2004]<\[u2004]1/2
and goes to zero for 1/2\[u2004]<\[u2004]\f[I]x\f[R]\[u2004]<\[u2004]1.
As with the sine wave, a square wave can be generated by passing as the
argument \f[I]x\f[R] a linear function of time such as
\f[I]\[*w]\f[R]\f[I]t\f[R]\[u2005]+\[u2005]\f[I]\[*f]\f[R], where
\f[I]\[*w]\f[R] controls the frequency of the wave and \f[I]\[*f]\f[R]
controls its phase.
.RE
.IP
.nf
\f[C]
square_wave(x)
\f[R]
.fi
.SS tan
.RS
.PP
Computes the tangent of the argument \f[I]x\f[R], where \f[I]x\f[R] is
in radians.
.RE
.IP
.nf
\f[C]
tan(x)
\f[R]
.fi
.SS tanh
.RS
.PP
Computes the hyperbolic tangent of the argument \f[I]x\f[R], where
\f[I]x\f[R] is in radians.
.RE
.IP
.nf
\f[C]
tanh(x)
\f[R]
.fi
.SS threshold_max
.RS
.PP
Returns one if the first argument \f[I]x\f[R] is greater than the
threshold given by the second argument \f[I]a\f[R], and zero otherwise.
If the optional third argument \f[I]b\f[R] is provided, an hysteresis of
width \f[I]b\f[R] is needed in order to reset the function value.
Default is no hysteresis, i.e.\ \f[I]b\f[R]\[u2004]=\[u2004]0.
.RE
.IP
.nf
\f[C]
threshold_max(x, a, [b])
\f[R]
.fi
.SS threshold_min
.RS
.PP
Returns one if the first argument \f[I]x\f[R] is less than the threshold
given by the second argument \f[I]a\f[R], and zero otherwise.
If the optional third argument \f[I]b\f[R] is provided, an hysteresis of
width \f[I]b\f[R] is needed in order to reset the function value.
Default is no hysteresis, i.e.\ \f[I]b\f[R]\[u2004]=\[u2004]0.
.RE
.IP
.nf
\f[C]
threshold_min(x, a, [b])
\f[R]
.fi
.SS triangular_wave
.RS
.PP
Computes a triangular wave betwen zero and one with a period equal to
one.
As with the sine wave, a triangular wave can be generated by passing as
the argument \f[I]x\f[R] a linear function of time such as
\f[I]\[*w]\f[R]\f[I]t\f[R]\[u2005]+\[u2005]\f[I]\[*f]\f[R], where $$
controls the frequency of the wave and \f[I]\[*f]\f[R] controls its
phase.
.RE
.IP
.nf
\f[C]
triangular_wave(x)
\f[R]
.fi
.SS Functionals
.SS derivative
.RS
.PP
Computes the derivative of the expression \f[I]f\f[R](\f[I]x\f[R]) given
in the first argument with respect to the variable \f[I]x\f[R] given in
the second argument at the point \f[I]x\f[R]\[u2004]=\[u2004]\f[I]a\f[R]
given in the third argument using an adaptive scheme.
The fourth optional argument \f[I]h\f[R] is the initial width of the
range the adaptive derivation method starts with.
The fifth optional argument \f[I]p\f[R] is a flag that indicates whether
a backward (\f[I]p\f[R]\[u2004]<\[u2004]0), centered
(\f[I]p\f[R]\[u2004]=\[u2004]0) or forward
(\f[I]p\f[R]\[u2004]>\[u2004]0) stencil is to be used.
This functional calls the GSL functions \f[C]gsl_deriv_central\f[R] or
\f[C]gsl_deriv_forward\f[R] according to the indicated flag \f[I]p\f[R].
Defaults are
\f[I]h\f[R]\[u2004]=\[u2004](1/2)^\[u2005]\[mi]\[u2005]10^\[u2004]\[~=]\[u2004]9.8\[u2005]\[tmu]\[u2005]10^\[u2005]\[mi]\[u2005]4^
and \f[I]p\f[R]\[u2004]=\[u2004]0.
.RE
.IP
.nf
\f[C]
derivative(f(x), x, a, [h], [p])
\f[R]
.fi
.SS func_min
.RS
.PP
Finds the value of the variable \f[I]x\f[R] given in the second argument
which makes the expression \f[I]f\f[R](\f[I]x\f[R]) given in the first
argument to take local a minimum in the in the range
[\f[I]a\f[R],\[u2006]\f[I]b\f[R]] given by the third and fourth
arguments.
If there are many local minima, the one that is closest to
(\f[I]a\f[R]\[u2005]+\[u2005]\f[I]b\f[R])/2 is returned.
The optional fifth argument \f[I]\[+e]\f[R] gives a relative tolerance
for testing convergence, corresponding to GSL \f[C]epsrel\f[R] (note
that \f[C]epsabs\f[R] is set also to \f[I]\[+e]\f[R]).
The sixth optional argument is an integer which indicates the algorithm
to use: 0 (default) is \f[C]quad_golden\f[R], 1 is \f[C]brent\f[R] and 2
is \f[C]goldensection\f[R].
See the GSL documentation for further information on the algorithms.
The seventh optional argument \f[I]p\f[R] is a flag that indicates how
to proceed if there is no local minimum in the range
[\f[I]a\f[R],\[u2006]\f[I]b\f[R]].
If \f[I]p\f[R]\[u2004]=\[u2004]0 (default), \f[I]a\f[R] is returned if
\f[I]f\f[R](\f[I]a\f[R])\[u2004]<\[u2004]\f[I]f\f[R](\f[I]b\f[R]) and
\f[I]b\f[R] otherwise.
If \f[I]p\f[R]\[u2004]=\[u2004]1 then the local minimum algorimth is
tried nevertheless.
Default is
\f[I]\[+e]\f[R]\[u2004]=\[u2004](1/2)^\[u2005]\[mi]\[u2005]20^\[u2004]\[~=]\[u2004]9.6\[u2005]\[tmu]\[u2005]10^\[u2005]\[mi]\[u2005]7^.
.RE
.IP
.nf
\f[C]
y = func_min(f(x), x, a, b, [eps], [alg], [p])
\f[R]
.fi
.SS gauss_kronrod
.RS
.PP
Computes the integral of the expression \f[I]f\f[R](\f[I]x\f[R]) given
in the first argument with respect to variable \f[I]x\f[R] given in the
second argument over the interval [\f[I]a\f[R],\[u2006]\f[I]b\f[R]]
given in the third and fourth arguments respectively using a
non-adaptive procedure which uses fixed Gauss-Kronrod-Patterson
abscissae to sample the integrand at a maximum of 87 points.
It is provided for fast integration of smooth functions.
The algorithm applies the Gauss-Kronrod 10-point, 21-point, 43-point and
87-point integration rules in succession until an estimate of the
integral is achieved within the relative tolerance given in the fifth
optional argument \f[I]\[+e]\f[R] It correspondes to GSL\[cq]s
\f[C]epsrel\f[R] parameter (\f[C]epsabs\f[R] is set to zero).
.PD 0
.P
.PD
The rules are designed in such a way that each rule uses all the results
of its predecessors, in order to minimize the total number of function
evaluations.
Defaults are
\f[I]\[+e]\f[R]\[u2004]=\[u2004](1/2)^\[u2005]\[mi]\[u2005]10^\[u2004]\[~=]\[u2004]10^\[u2005]\[mi]\[u2005]3^.
See GSL reference for further information.
.RE
.IP
.nf
\f[C]
gauss_kronrod(f(x), x, a, b, [eps])
\f[R]
.fi
.SS gauss_legendre
.RS
.PP
Computes the integral of the expression \f[I]f\f[R](\f[I]x\f[R]) given
in the first argument with respect to variable \f[I]x\f[R] given in the
second argument over the interval [\f[I]a\f[R],\[u2006]\f[I]b\f[R]]
given in the third and fourth arguments respectively using the
\f[I]n\f[R]-point Gauss-Legendre rule, where \f[I]n\f[R] is given in the
optional fourth argument.
It is provided for fast integration of smooth functions with known
polynomic order (it is exact for polynomials of order
2\f[I]n\f[R]\[u2005]\[mi]\[u2005]1).
This functional calls GSL function \f[C]gsl_integration_glfixedp\f[R].
Default is \f[I]n\f[R]\[u2004]=\[u2004]12.
See GSL reference for further information.
.RE
.IP
.nf
\f[C]
gauss_legendre(f(x), x, a, b, [n])
\f[R]
.fi
.SS integral
.RS
.PP
Computes the integral of the expression \f[I]f\f[R](\f[I]x\f[R]) given
in the first argument with respect to variable \f[I]x\f[R] given in the
second argument over the interval [\f[I]a\f[R],\[u2006]\f[I]b\f[R]]
given in the third and fourth arguments respectively using an adaptive
scheme, in which the domain is divided into a number of maximum number
of subintervals and a fixed-point Gauss-Kronrod-Patterson scheme is
applied to each quadrature subinterval.
Based on an estimation of the error commited, one or more of these
subintervals may be split to repeat the numerical integration alogorithm
with a refined division.
The fifth optional argument \f[I]\[+e]\f[R] is is a relative tolerance
used to check for convergence.
It correspondes to GSL\[cq]s \f[C]epsrel\f[R] parameter
(\f[C]epsabs\f[R] is set to zero).
The sixth optional argument
1\[u2004]\[<=]\[u2004]\f[I]k\f[R]\[u2004]\[<=]\[u2004]6 is an integer
key that indicates the integration rule to apply in each interval.
It corresponds to GSL\[cq]s parameter \f[C]key\f[R].
The seventh optional argument gives the maximum number of subdivisions,
which defaults to 1024.
If the integration interval [\f[I]a\f[R],\[u2006]\f[I]b\f[R]] if finite,
this functional calls the GSL function \f[C]gsl_integration_qag\f[R].
If \f[I]a\f[R] is less that minus the internal variable
\f[C]infinite\f[R], \f[I]b\f[R] is greater that \f[C]infinite\f[R] or
both conditions hold, GSL functions \f[C]gsl_integration_qagil\f[R],
\f[C]gsl_integration_qagiu\f[R] or \f[C]gsl_integration_qagi\f[R] are
called.
The condition of finiteness of a fixed range
[\f[I]a\f[R],\[u2006]\f[I]b\f[R]] can thus be changed by modifying the
internal variable \f[C]infinite\f[R].
Defaults are
\f[I]\[+e]\f[R]\[u2004]=\[u2004](1/2)^\[u2005]\[mi]\[u2005]10^\[u2004]\[~=]\[u2004]10^\[u2005]\[mi]\[u2005]3^
and \f[I]k\f[R]\[u2004]=\[u2004]3.
The maximum numbers of subintervals is limited to 1024.
Due to the adaptivity nature of the integration method, this function
gives good results with arbitrary integrands, even for infinite and
semi-infinite integration ranges.
However, for certain integrands, the adaptive algorithm may be too
expensive or even fail to converge.
In these cases, non-adaptive quadrature functionals ought to be used
instead.
See GSL reference for further information.
.RE
.IP
.nf
\f[C]
integral(f(x), x, a, b, [eps], [k], [max_subdivisions])
\f[R]
.fi
.SS prod
.RS
.PP
Computes product of the
\f[I]N\f[R]\[u2004]=\[u2004]\f[I]b\f[R]\[u2005]\[mi]\[u2005]\f[I]a\f[R]
expressions \f[I]f\f[R](\f[I]i\f[R]) given in the first argument by
varying the variable\[ti]\f[I]i\f[R] given in the second argument
between\[ti]\f[I]a\f[R] given in the third argument and\[ti]\f[I]b\f[R]
given in the fourth
argument,\[ti]\f[I]i\f[R]\[u2004]=\[u2004]\f[I]a\f[R],\[u2006]\f[I]a\f[R]\[u2005]+\[u2005]1,\[u2006]\&...,\[u2006]\f[I]b\f[R]\[u2005]\[mi]\[u2005]1,\[u2006]\f[I]b\f[R].
.RE
.IP
.nf
\f[C]
prod(f(i), i, a, b)
\f[R]
.fi
.SS root
.RS
.PP
Computes the value of the variable \f[I]x\f[R] given in the second
argument which makes the expression \f[I]f\f[R](\f[I]x\f[R]) given in
the first argument to be equal to zero by using a root bracketing
algorithm.
The root should be in the range [\f[I]a\f[R],\[u2006]\f[I]b\f[R]] given
by the third and fourth arguments.
The optional fifth argument \f[I]\[+e]\f[R] gives a relative tolerance
for testing convergence, corresponding to GSL \f[C]epsrel\f[R] (note
that \f[C]epsabs\f[R] is set also to \f[I]\[+e]\f[R]).
The sixth optional argument is an integer which indicates the algorithm
to use: 0 (default) is \f[C]brent\f[R], 1 is \f[C]falsepos\f[R] and 2 is
\f[C]bisection\f[R].
See the GSL documentation for further information on the algorithms.
The seventh optional argument \f[I]p\f[R] is a flag that indicates how
to proceed if the sign of \f[I]f\f[R](\f[I]a\f[R]) is equal to the sign
of \f[I]f\f[R](\f[I]b\f[R]).
If \f[I]p\f[R]\[u2004]=\[u2004]0 (default) an error is raised, otherwise
it is not.
If more than one root is contained in the specified range, the first one
to be found is returned.
The initial guess is
\f[I]x\f[R]~0~\[u2004]=\[u2004](\f[I]a\f[R]\[u2005]+\[u2005]\f[I]b\f[R])/2.
If no roots are contained in the range and
\f[I]p\f[R]\[u2004]\[!=]\[u2004]0, the returned value can be any value.
Default is
\f[I]\[+e]\f[R]\[u2004]=\[u2004](1/2)^\[u2005]\[mi]\[u2005]10^\[u2004]\[~=]\[u2004]10^3^.
.RE
.IP
.nf
\f[C]
root(f(x), x, a, b, [eps], [alg], [p])
\f[R]
.fi
.SS sum
.RS
.PP
Computes sum of the
\f[I]N\f[R]\[u2004]=\[u2004]\f[I]b\f[R]\[u2005]\[mi]\[u2005]\f[I]a\f[R]
expressions \f[I]f\f[R]~\f[I]i\f[R]~ given in the first argument by
varying the variable \f[I]i\f[R] given in the second argument between
\f[I]a\f[R] given in the third argument and \f[I]b\f[R] given in the
fourth argument,
\f[I]i\f[R]\[u2004]=\[u2004]\f[I]a\f[R],\[u2006]\f[I]a\f[R]\[u2005]+\[u2005]1,\[u2006]\&...,\[u2006]\f[I]b\f[R]\[u2005]\[mi]\[u2005]1,\[u2006]\f[I]b\f[R].
.RE
.IP
.nf
\f[C]
sum(f_i, i, a, b)
\f[R]
.fi
.SS Vector functions
.SS vecdot
.RS
.PP
Computes the dot product between vectors \f[I]a\[u20D7]\f[R] and
\f[I]b\[u20D7]\f[R], which should have the same size.
.RE
.IP
.nf
\f[C]
vecdot(a,b)
\f[R]
.fi
.SS vecmax
.RS
.PP
Returns the biggest element of vector \f[I]b\[u20D7]\f[R], taking into
account its sign (i.e.\ 1\[u2004]>\[u2004]\[u2005]\[mi]\[u2005]2).
.RE
.IP
.nf
\f[C]
vecmax(b)
\f[R]
.fi
.SS vecmaxindex
.RS
.PP
Returns the index of the biggest element of vector \f[I]b\[u20D7]\f[R],
taking into account its sign
(i.e.\ 2\[u2004]>\[u2004]\[u2005]\[mi]\[u2005]1).
.RE
.IP
.nf
\f[C]
vecmaxindex(b)
\f[R]
.fi
.SS vecmin
.RS
.PP
Returns the smallest element of vector \f[I]b\[u20D7]\f[R], taking into
account its sign (i.e.\ \[u2005]\[mi]\[u2005]2\[u2004]<\[u2004]1).
.RE
.IP
.nf
\f[C]
vecmin(b)
\f[R]
.fi
.SS vecminindex
.RS
.PP
Returns the index of the smallest element of vector \f[I]b\[u20D7]\f[R],
taking into account its sign
(i.e.\ \[u2005]\[mi]\[u2005]2\[u2004]<\[u2004]1).
.RE
.IP
.nf
\f[C]
vecminindex(b)
\f[R]
.fi
.SS vecnorm
.RS
.PP
Computes euclidean norm of vector \f[I]b\[u20D7]\f[R].
Other norms can be computed explicitly using the \f[C]sum\f[R]
functional, as illustrated in the example.
.RE
.IP
.nf
\f[C]
vecnorm(b)
\f[R]
.fi
.SS vecsize
.RS
.PP
Returns the size of vector \f[I]b\[u20D7]\f[R].
.RE
.IP
.nf
\f[C]
vecsize(b)
\f[R]
.fi
.SS vecsum
.RS
.PP
Computes the sum of all the components of vector \f[I]b\[u20D7]\f[R].
.RE
.IP
.nf
\f[C]
vecsum(b)
\f[R]
.fi
.SH SEE ALSO
.PP
\f[C]gnuplot\f[R](1)
.PP
The wasora Real Book at <https://www.seamplex.com/wasora/doc/realbook/>
contains fully-discussed examples.
.PP
The wasora web page contains full source code, updates, examples, V&V
cases and full reference: <https://www.seamplex.com/wasora>.
.SH AUTHOR
.PP
Jeremy Theler <https://www.seamplex.com>
.SH AUTHORS
Jeremy Theler.
